<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>

</html>
<script>
    原始值·· 存在栈（ stack） 中的简单数据类型， 也就是说特闷的值直接存在变量的访问位置，
    引用值
    存储在堆（ heap） 中的对象， 也就是说， 存储在变量出的值是一个指针（ point）， 指向存储对象的内存处
    var:
    当通过var创建一个变量的额时候， 会进行局解释（ 变量提升）
    因为var会句解析， 所有变量会当做属性存到全局的活动变量对象下（ window下） 不支持块级作用域不会主动存每次循环的值

    let：
        当通过var创建的一个变量的时候， 不会进行与解析（ 不会变量提升） 不会再window下挂属性在定义变量之前会访问这个变量， 之前访问的空间叫暂存死区
    支持块级作用域
    会把每次循环的值存储起来‘ 不能声明的同名变量函数参数

    const： 常量（ 不可变的量）
    当声明一个变量， 不允许改变的时候就用const定义
    不能声明同名变量， 函数， 参数
    const box = document.getElementById('box')

    注意：
    const 赋值的数据， 他会监控这个数据的地址

    JS是个弱鸡语言 ^ - ^

        let num: number = 10;
    num = '10';

    块： {}
    在块套块中， 子块有函数， 如果在父块或者父块的上方访问这个函数那么都是 undefined
    如果在子块的下方访问这个函数， 就能找到这个函数
    for (let i = 0; i < 5; i++) {

    }
    console.log(a) {
        var a = 10;
    }
    var a = 10; {
        let a = 10;
        console.log(a)
    } {
        // let a = 20;
        // console.log(a);
        // console.log(fn);
        // function fn(){console.log(1)}
        {
            function fn() {
                console.log(1)
            }
        }
        console.log(fn);
    }

    function fn() {}
    let btns = document.querySelectorAll
    utton ');
    for (let i = 0; i < btns.length; i++) {
        btns[i].onclick = function () {
            alert(i);
        }
    }
    fn(i);

    function fn(i) {
        btns[i].onclick = function () {
            alert(i);
        }
    }
    let a = 10;
    let a = 20;
    const a = 10;
    const a = 20;
    var a = 10;
    var a = 20;
    console.log(a);
    const a = 10;
    a = 20; //会报错
    st obj = {
          
      obj = 10;
      b = 100;
           
            let fn = 4;

            function fn(a) {
                // let a = 10
            }
            fn(1)
    }
</script>